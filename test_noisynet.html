<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NoisyNet Test</title>
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
</head>
<body>
    <h1>NoisyNet Layer Test</h1>
    <div id="output"></div>
    
    <script type="module">
        // Define the NoisyDense layer
        class NoisyDense extends tf.layers.Layer {
            constructor(config) {
                super(config);
                this.units = config.units;
                this.activation = config.activation || 'linear';
                this.useBias = config.useBias !== undefined ? config.useBias : true;
                
                this.inputDim = null;
                this.muWeight = null;
                this.sigmaWeight = null;
                this.muBias = null;
                this.sigmaBias = null;
                this.epsilonInput = null;
                this.epsilonOutput = null;
            }
            
            build(inputShape) {
                this.inputDim = inputShape[inputShape.length - 1];
                
                const muRange = 1.0 / Math.sqrt(this.inputDim);
                const sigmaInit = 0.017;
                
                this.muWeight = this.addWeight(
                    'mu_weight',
                    [this.inputDim, this.units],
                    'float32',
                    tf.initializers.randomUniform({minval: -muRange, maxval: muRange})
                );
                
                this.sigmaWeight = this.addWeight(
                    'sigma_weight',
                    [this.inputDim, this.units],
                    'float32',
                    tf.initializers.constant({value: sigmaInit})
                );
                
                if (this.useBias) {
                    this.muBias = this.addWeight(
                        'mu_bias',
                        [this.units],
                        'float32',
                        tf.initializers.randomUniform({minval: -muRange, maxval: muRange})
                    );
                    
                    this.sigmaBias = this.addWeight(
                        'sigma_bias',
                        [this.units],
                        'float32',
                        tf.initializers.constant({value: sigmaInit})
                    );
                }
                
                super.build(inputShape);
            }
            
            factorizedNoise(size) {
                return tf.tidy(() => {
                    const noise = tf.randomNormal([size]);
                    const sign = tf.sign(noise);
                    const abs = tf.abs(noise);
                    const sqrt = tf.sqrt(abs);
                    return tf.mul(sign, sqrt);
                });
            }
            
            resetNoise() {
                this.epsilonInput = this.factorizedNoise(this.inputDim);
                this.epsilonOutput = this.factorizedNoise(this.units);
            }
            
            call(inputs, kwargs) {
                return tf.tidy(() => {
                    const input = inputs instanceof Array ? inputs[0] : inputs;
                    
                    this.resetNoise();
                    
                    const epsilonWeight = tf.outerProduct(this.epsilonInput, this.epsilonOutput);
                    
                    const noisyWeight = tf.add(
                        this.muWeight.read(),
                        tf.mul(this.sigmaWeight.read(), epsilonWeight)
                    );
                    
                    let output = tf.matMul(input, noisyWeight);
                    
                    if (this.useBias) {
                        const noisyBias = tf.add(
                            this.muBias.read(),
                            tf.mul(this.sigmaBias.read(), this.epsilonOutput)
                        );
                        
                        output = tf.add(output, noisyBias);
                    }
                    
                    if (this.activation !== 'linear') {
                        const activationFn = tf.layers.activation({activation: this.activation});
                        output = activationFn.apply(output);
                    }
                    
                    return output;
                });
            }
            
            computeOutputShape(inputShape) {
                return [inputShape[0], this.units];
            }
            
            getConfig() {
                const config = {
                    units: this.units,
                    activation: this.activation,
                    useBias: this.useBias
                };
                const baseConfig = super.getConfig();
                return Object.assign({}, baseConfig, config);
            }
            
            static get className() {
                return 'NoisyDense';
            }
        }
        
        // Register the custom layer
        tf.serialization.registerClass(NoisyDense);
        
        // Test the NoisyDense layer
        async function testNoisyDense() {
            const output = document.getElementById('output');
            output.innerHTML = '<p>Testing NoisyDense layer...</p>';
            
            try {
                // Create a simple model with NoisyDense layers
                const input = tf.input({shape: [10]});
                const hidden = tf.layers.dense({
                    units: 32,
                    activation: 'relu',
                    name: 'dense_1'
                }).apply(input);
                
                const noisyLayer = new NoisyDense({
                    units: 4,
                    activation: 'linear',
                    name: 'noisy_output'
                }).apply(hidden);
                
                const model = tf.model({
                    inputs: input,
                    outputs: noisyLayer,
                    name: 'test_model'
                });
                
                output.innerHTML += '<p>✓ Model created successfully</p>';
                
                // Test forward pass
                const testInput = tf.randomNormal([1, 10]);
                const prediction1 = model.predict(testInput);
                const prediction2 = model.predict(testInput);
                
                output.innerHTML += '<p>✓ Forward pass successful</p>';
                
                // Verify that outputs are different (due to noise)
                const diff = tf.sub(prediction1, prediction2);
                const diffNorm = tf.norm(diff).dataSync()[0];
                
                if (diffNorm > 0.001) {
                    output.innerHTML += `<p>✓ Noise working correctly (difference norm: ${diffNorm.toFixed(4)})</p>`;
                } else {
                    output.innerHTML += `<p>⚠ Warning: Noise might not be working (difference norm: ${diffNorm.toFixed(4)})</p>`;
                }
                
                // Check trainable weights
                const trainableWeights = model.trainableWeights;
                output.innerHTML += `<p>✓ Found ${trainableWeights.length} trainable weights</p>`;
                
                // List weight names
                output.innerHTML += '<p>Trainable weights:</p><ul>';
                trainableWeights.forEach(w => {
                    output.innerHTML += `<li>${w.name}</li>`;
                });
                output.innerHTML += '</ul>';
                
                // Compile and test gradient computation
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError'
                });
                
                output.innerHTML += '<p>✓ Model compiled successfully</p>';
                
                // Test training step
                const xs = tf.randomNormal([4, 10]);
                const ys = tf.randomNormal([4, 4]);
                
                const history = await model.fit(xs, ys, {
                    epochs: 1,
                    verbose: 0
                });
                
                output.innerHTML += `<p>✓ Training step successful (loss: ${history.history.loss[0].toFixed(4)})</p>`;
                
                // Model summary
                output.innerHTML += '<p><strong>Model Summary:</strong></p>';
                model.summary();
                
                output.innerHTML += '<p><strong>All tests passed! ✓</strong></p>';
                
                // Cleanup
                testInput.dispose();
                prediction1.dispose();
                prediction2.dispose();
                diff.dispose();
                xs.dispose();
                ys.dispose();
                model.dispose();
                
            } catch (error) {
                output.innerHTML += `<p style="color: red;">✗ Error: ${error.message}</p>`;
                console.error(error);
            }
        }
        
        // Run the test when the page loads
        testNoisyDense();
    </script>
</body>
</html>
